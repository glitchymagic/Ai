const puppeteer = require('puppeteer-extra');
const StealthPlugin = require('puppeteer-extra-plugin-stealth');
const { GoogleGenerativeAI } = require('@google/generative-ai');

// Import features
const SearchEngine = require('./features/search-engine');
const Memory = require('./features/memory');
const LMStudioAI = require('./features/lmstudio-ai');
const ContentFilter = require('./features/content-filter');
const ConversationChecker = require('./features/conversation-checker');
const ConversationTracker = require('./features/conversation-tracker');
const PokemonCulture = require('./features/pokemon-culture');
const CardKnowledge = require('./features/card-knowledge');
const ResponseVariety = require('./features/response-variety');
const ContextAnalyzer = require('./features/context-analyzer');
const VisualAnalyzer = require('./features/visual-analyzer');
const AdvancedContextExtractor = require('./features/advanced-context');
const HumanLikeResponses = require('./features/human-like-responses');
const EngagementSelector = require('./features/engagement-selector');
const AuthorityResponses = require('./features/authority-responses');
const SentimentAnalyzer = require('./features/sentiment-analyzer');
const TimestampFilter = require('./features/timestamp-filter');
const HumanSearch = require('./features/human-search');
const priceEngine = require('./price-engine/index.js');
const EnhancedPriceResponses = require('./features/enhanced-price-responses');
const StrategyPicker = require('./features/strategy-picker');
const AntiScam = require('./features/anti-scam');
const DecisionTrace = require('./features/decision-trace');

puppeteer.use(StealthPlugin());

const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
if (!GEMINI_API_KEY) throw new Error('GEMINI_API_KEY environment variable is required');
const genAI = new GoogleGenerativeAI(GEMINI_API_KEY);

const model = genAI.getGenerativeModel({ 
    model: "gemini-1.5-flash",
    generationConfig: {
        maxOutputTokens: 100,
        temperature: 0.7,
    }
});

// Helper function to clamp tweets to 280 chars consistently
function clampTweet(s, max = 280) {
    const conf = (s.match(/Confidence:\s*\d{1,3}%/i) || [])[0];
    const body = conf ? s.replace(/Confidence:\s*\d{1,3}%/i, '').trim() : s.trim();
    const pad = conf ? (' ' + conf) : '';
    if ((body + pad).length <= max) return (body + pad);
    const words = body.split(/\s+/);
    let out = '';
    for (const w of words) { 
        if ((out + ' ' + w + pad).length > max) break; 
        out += (out ? ' ' : '') + w; 
    }
    return (out + pad).trim();
}

class ContextualPokemonBot {
    constructor() {
        this.browser = null;
        this.page = null;
        this.replyCount = 106; // Continue from where we left off
        this.repliedUsers = new Set();
        this.startTime = Date.now();
        
        // Initialize features
        this.searchEngine = new SearchEngine();
        this.memory = new Memory();
        this.lmStudioAI = new LMStudioAI();
        this.contentFilter = new ContentFilter();
        this.pokemonCulture = new PokemonCulture();
        this.cardKnowledge = new CardKnowledge();
        this.responseVariety = new ResponseVariety();
        this.contextAnalyzer = new ContextAnalyzer();
        this.advancedContext = new AdvancedContextExtractor();
        this.humanLike = new HumanLikeResponses();
        this.engagementSelector = new EngagementSelector();
        this.authorityResponses = new AuthorityResponses();
        this.sentimentAnalyzer = new SentimentAnalyzer();
        this.timestampFilter = new TimestampFilter();
        this.humanSearch = new HumanSearch();
        this.priceResponses = new EnhancedPriceResponses();
        this.visualAnalyzer = null; // Will initialize after page is ready
        this.conversationChecker = null; // Will initialize after page is ready
        this.conversationTracker = new ConversationTracker();
        this.strategyPicker = new StrategyPicker();
        this.antiScam = new AntiScam();
        this.decisionTrace = new DecisionTrace();
        
        // Initialize price engine
        this.priceEngineReady = false;
        priceEngine.initialize().then(() => {
            this.priceEngineReady = true;
            console.log('   üí∞ Price engine ready with real-time data');
        }).catch(err => {
            console.log('   ‚ö†Ô∏è Price engine init failed:', err.message);
        });
        
        this.geminiFailures = 0;
        
        // Rate limiting
        this.sessionStartTime = Date.now();
        this.repliesThisHour = [];
        this.lastBreakReplyCount = this.replyCount;
        
        // Stats
        this.stats = {
            postsAnalyzed: 0,
            postsFiltered: 0,
            successfulEngagements: 0
        };
    }

    async generateThreadAwareResponse(username, latestMessage, threadContext) {
        // Build comprehensive context from thread
        let contextSummary = `Thread has ${threadContext.threadLength} messages about ${threadContext.mainTopic}.\n`;
        
        // Include key conversation points
        if (threadContext.fullConversation.length > 1) {
            contextSummary += "Previous discussion:\n";
            // Get last 3 messages before the current one
            const previousMsgs = threadContext.fullConversation.slice(-4, -1);
            previousMsgs.forEach(msg => {
                const snippet = msg.text.length > 60 ? msg.text.substring(0, 57) + "..." : msg.text;
                contextSummary += `- @${msg.username}: "${snippet}"\n`;
            });
        }
        
        // Try Gemini with thread context
        if (this.geminiFailures < 5) {
            try {
                // Use top-level model instance
                
                const prompt = `
You're replying in a Pok√©mon TCG thread. Use the context + numbers below. One tweet only, <=280 chars.
Rules: add 1 stat (price/Œî%/n sales) if available; reference the convo; no hashtags; light Gen-Z tone; end crisp.

Context: Thread=${threadContext.threadLength}, Topic=${threadContext.mainTopic}
Recent:
${threadContext.fullConversation.slice(-3).map(m => `‚Ä¢ @${m.username}: ${m.text.slice(0,80)}`).join('\n')}

Latest from @${username}: "${latestMessage}"

Reply:
`.trim();

                const result = await model.generateContent(prompt);
                let response = result.response.text().trim()
                    .replace(/^[\"']|[\"']$/g, '')
                    .replace(/#\w+/g, '')
                    .split('\n')[0]
                    .trim();
                
                // Use clampTweet for consistent handling
                response = clampTweet(response, 280);
                
                console.log(`   üßµ [Thread-aware] "${response}"`);
                return response;
                
            } catch (error) {
                console.log(`   ‚ö†Ô∏è Thread response failed, using regular response`);
            }
        }
        
        // Fallback to regular response
        return this.generateContextualResponse(username, latestMessage, threadContext.hasImages);
    }

    async generateContextualResponse(username, tweetContent, hasImages = false, visualData = null) {
        // CRITICAL: Make response actually relate to the tweet content
        
        // FIRST: Analyze sentiment to avoid responding to complaints/negative posts
        const sentimentAnalysis = this.sentimentAnalyzer.analyzeSentiment(tweetContent);
        console.log(`   üìä Sentiment: ${sentimentAnalysis.sentiment} (${sentimentAnalysis.confidence}) - ${sentimentAnalysis.reason}`);
        
        const engagementDecision = this.sentimentAnalyzer.shouldEngageWithSentiment(sentimentAnalysis);
        if (!engagementDecision.engage) {
            console.log(`   üö´ Skipping due to sentiment: ${engagementDecision.reason}`);
            return null; // Don't engage with negative content
        }
        
        // SECOND: understand what type of post this is
        const textLower = tweetContent.toLowerCase();
        const isMarketAnalysis = textLower.includes('market') || textLower.includes('global') || 
                               textLower.includes('collectibles') || textLower.includes('valued at') ||
                               textLower.includes('industry') || textLower.includes('billion') ||
                               textLower.includes('revenue') || textLower.includes('growth');
        const isNewsPost = textLower.includes('announced') || textLower.includes('revealed') || 
                         textLower.includes('coming') || textLower.includes('release') ||
                         textLower.includes('launching') || textLower.includes('introducing');
        const isSelling = textLower.includes('selling') || textLower.includes('for sale') || 
                        textLower.includes('fs') || textLower.includes('wts') || 
                        textLower.includes('$') && (textLower.includes('dm') || textLower.includes('message')) ||
                        textLower.includes('available') || textLower.includes('claim') ||
                        (textLower.includes('sale') && !textLower.includes('for sale'));
        const isRaffle = textLower.includes('spot') && textLower.includes('$') ||
                       textLower.includes('raffle') || textLower.includes('break') ||
                       textLower.includes('giveaway') || textLower.includes('retweet to enter');
        const isPriceQuestion = textLower.includes('worth') || textLower.includes('price') || 
                              textLower.includes('value') || textLower.includes('how much');
        const isShowingCards = hasImages && (textLower.includes('pull') || textLower.includes('got') || 
                             textLower.includes('collection') || textLower.includes('mail') ||
                             textLower.includes('new') || textLower.includes('arrived'));
        const isOpinion = textLower.includes('unpopular opinion') || textLower.includes('hot take') ||
                        textLower.includes('overrated') || textLower.includes('overhyped') ||
                        textLower.includes('underrated') || textLower.includes('think') && textLower.includes('is');
        
        // Handle raffles/giveaways (skip them)
        if (isRaffle) {
            console.log(`   üé≤ [Raffle/Giveaway] Skipping`);
            return null; // Actually skip, don't reply
        }
        
        // Handle opinion/hot take posts
        if (isOpinion) {
            const opinionResponses = [
                "interesting take",
                "i can see both sides tbh",
                "fair point actually",
                "depends how you look at it",
                "respectfully disagree but i get it",
                "you're not wrong",
                "that's a hot take for sure",
                "valid opinion"
            ];
            
            // Specific responses for common opinions
            if (textLower.includes('overhyped') || textLower.includes('overrated')) {
                const overhypedResponses = [
                    "market says otherwise but i feel you",
                    "nostalgia tax is real",
                    "fair but the demand is still there",
                    "true but iconic is iconic",
                    "i get it, prices are wild"
                ];
                const response = overhypedResponses[Math.floor(Math.random() * overhypedResponses.length)];
                console.log(`   üí≠ [Opinion] "${response}"`);
                return response;
            }
            
            const response = opinionResponses[Math.floor(Math.random() * opinionResponses.length)];
            console.log(`   üí≠ [Opinion] "${response}"`);
            return response;
        }
        
        // Handle sales posts appropriately (no buying interest)
        if (isSelling) {
            const sellingResponses = await this.pokemonCulture.getContextualResponse(tweetContent, 'selling');
            if (sellingResponses && sellingResponses.length > 0) {
                const response = sellingResponses[Math.floor(Math.random() * sellingResponses.length)];
                console.log(`   üí∏ [Sale] "${response}"`);
                return response;
            }
        }
        
        // SKIP price responses for non-card posts
        if (isMarketAnalysis || isNewsPost) {
            // For market analysis, give intelligent commentary
            if (isMarketAnalysis) {
                const marketResponses = [
                    "pokemon leading the way as always",
                    "tcg market growth looking strong",
                    "interesting data, wonder what % is pokemon",
                    "collectibles booming, good for the hobby",
                    "market fundamentals looking solid"
                ];
                const response = marketResponses[Math.floor(Math.random() * marketResponses.length)];
                console.log(`   üìà [Market Analysis] "${response}"`);
                return response;
            }
            
            // For news, react appropriately
            if (isNewsPost) {
                const newsResponses = [
                    "hyped for this",
                    "gonna be huge",
                    "interesting development",
                    "can't wait to see more",
                    "this changes things"
                ];
                const response = newsResponses[Math.floor(Math.random() * newsResponses.length)];
                console.log(`   üì∞ [News] "${response}"`);
                return response;
            }
        }
        
        // CHECK FOR ACTUAL PRICE QUESTIONS - with real card context
        if (isPriceQuestion && this.priceEngineReady) {
            const cards = this.extractCardNames(textLower);
            if (cards.length > 0) {
                const priceResponse = await this.generatePriceAwareResponse(tweetContent, username, hasImages);
                if (priceResponse) {
                    console.log(`   üí∞ [Price] "${priceResponse}"`);
                    return priceResponse;
                }
            }
        }
        
        // For posts showing cards, comment on what they're showing
        // BUT ONLY if the text actually indicates they're showing something
        if (isShowingCards && visualData && 
            !textLower.includes('sold out') && !textLower.includes('all gone') &&
            !textLower.includes('none left') && !textLower.includes('empty')) {
            const visualResponse = this.visualAnalyzer.generateVisualResponse(tweetContent, visualData);
            if (visualResponse) {
                console.log(`   üñºÔ∏è [Visual] "${visualResponse}"`);
                return visualResponse;
            }
        }
        
        // Handle restock/shopping posts (but only positive ones - sentiment already filtered negatives)
        if ((textLower.includes('restock') || textLower.includes('found at') || 
            textLower.includes('target') || textLower.includes('walmart') ||
            textLower.includes('costco') || textLower.includes('gamestop')) &&
            sentimentAnalysis.sentiment !== 'negative' && sentimentAnalysis.sentiment !== 'very_negative') {
            
            // Handle queue/line situations
            if (textLower.includes('queue') || textLower.includes('line') || 
                textLower.includes('waiting')) {
                const queueResponses = [
                    "hope the wait is worth it",
                    "dedication! good luck",
                    "that line looks crazy",
                    "costco lines are no joke",
                    "fingers crossed they don't sell out"
                ];
                const response = queueResponses[Math.floor(Math.random() * queueResponses.length)];
                console.log(`   üõí [Queue/Line] "${response}"`);
                return response;
            }
            
            if (textLower.includes('gone') || textLower.includes('sold out') || 
                textLower.includes('empty') || textLower.includes('nothing')) {
                const emptyResponses = [
                    "pain.. better luck next time",
                    "story of my life tbh",
                    "restocks been rough lately",
                    "they go so fast",
                    "felt that"
                ];
                const response = emptyResponses[Math.floor(Math.random() * emptyResponses.length)];
                console.log(`   üõí [Empty Restock] "${response}"`);
                return response;
            } else {
                const restockResponses = [
                    "nice find!",
                    "lucky! my stores are always empty",
                    "W restock",
                    "what did you grab?",
                    "jealous, my target never has anything"
                ];
                const response = restockResponses[Math.floor(Math.random() * restockResponses.length)];
                console.log(`   üõí [Restock] "${response}"`);
                return response;
            }
        }
        
        // AVOID generic human responses for specific post types
        if (!isMarketAnalysis && !isNewsPost && !isOpinion && Math.random() < 0.3) { // Reduced to 30%
            // Only use human responses for appropriate contexts
            const isShowingOff = textLower.includes('pull') || textLower.includes('got') || 
                               textLower.includes('finally') || textLower.includes('grail') ||
                               (hasImages && (textLower.includes('collection') || textLower.includes('mail')));
            
            if (isShowingOff) {
                const humanResponse = await this.humanLike.generateHumanResponse(tweetContent, { 
                    hasImages, 
                    username,
                    imageUrl: visualData?.imageUrl 
                });
                
                // Filter out inappropriate responses
                if (humanResponse && 
                    !humanResponse.includes('tcgplayer has it at') &&
                    !humanResponse.includes('jealous') && !isOpinion) { // Don't say jealous unless they're showing off
                    console.log(`   üí¨ [Human] "${humanResponse}"`);
                    return humanResponse;
                }
            }
        }
        
        // SECOND: Try authority-level responses first for expertise demonstration
        if (Math.random() < 0.3) { // 30% chance for authority response
            const authorityResponse = this.authorityResponses.generateAuthorityResponse(tweetContent, hasImages);
            if (authorityResponse && this.authorityResponses.isExpertLevel(authorityResponse)) {
                console.log(`   üëë [Authority] "${authorityResponse}"`);
                return authorityResponse;
            }
        }
        
        // THIRD: Try advanced context extraction for ultra-specific responses
        const advancedContext = this.advancedContext.extractFullContext(tweetContent, hasImages);
        const specificResponse = this.advancedContext.generateSpecificResponse(advancedContext, tweetContent);
        
        if (specificResponse && this.advancedContext.isValuableResponse(specificResponse) && Math.random() < 0.2) {
            console.log(`   üéØ [Advanced] "${specificResponse}"`);
            return specificResponse;
        }
        
        // If we have visual data, prioritize visual-specific responses
        if (visualData && visualData.analysis && (hasImages || visualData.hasVideo)) {
            const visualResponse = this.visualAnalyzer.generateVisualResponse(tweetContent, visualData);
            if (visualResponse && Math.random() < 0.8) {  // 80% chance for visual-aware response
                console.log(`   üñºÔ∏è [Visual] "${visualResponse}"`);
                return visualResponse;
            }
        }
        
        // Use advanced context analyzer for best responses
        const contextualResponse = this.contextAnalyzer.generateContextualResponse(tweetContent, hasImages);
        if (contextualResponse && Math.random() < 0.6) {  // Reduced to 60% since we have advanced context
            console.log(`   üìä [Context] "${contextualResponse}"`);
            return contextualResponse;
        }
        
        // Check card knowledge for helpful responses
        const helpfulResponse = this.cardKnowledge.generateHelpfulResponse(tweetContent, hasImages);
        if (helpfulResponse && Math.random() < 0.5) {  // 50% chance for helpful response
            console.log(`   üí° [Knowledge] "${helpfulResponse}"`);
            return helpfulResponse;
        }
        
        // Try varied response patterns
        const variedResponse = this.responseVariety.getVariedResponse(tweetContent, hasImages);
        if (variedResponse && Math.random() < 0.3) {  // 30% chance for varied response
            console.log(`   üé≤ [Variety] "${variedResponse}"`);
            return variedResponse;
        }
        
        // Check for memes very occasionally
        const memeResponse = this.pokemonCulture.generateMemeResponse(tweetContent);
        if (memeResponse && Math.random() < 0.05) {  // 5% chance to use meme response
            return memeResponse;
        }
        
        // Check if this is a reply to us (conversation)
        const isConversation = tweetContent.toLowerCase().includes('@glitchygradeai');
        const isPokemonRelated = this.contentFilter.isPokemonRelated(tweetContent.toLowerCase());
        
        // Try Gemini first
        if (this.geminiFailures < 5) {
            try {
                let prompt;
                if (isConversation) {
                    // More conversational for replies
                    if (isPokemonRelated) {
                        prompt = `You're a Pokemon card collector chatting on Twitter.

@${username} replied: "${tweetContent}"
${hasImages ? 'They posted a pic' : ''}

Reply naturally as a collector:
- Match their energy level
- Comment specifically on what they said
- Use minimal slang - only when it fits naturally
- Keep it brief (under 25 words)
- Sound genuine, not forced

Your reply:`;
                    } else {
                        // Non-Pokemon conversation - be friendly and natural
                        prompt = `You collect Pokemon cards and someone's talking to you.

@${username} said: "${tweetContent}"
${hasImages ? 'With a pic' : ''}

Reply naturally:
- Be chill and friendly
- Talk about whatever they brought up
- Don't force Pokemon into it
- Use casual internet speak
- Keep it real

Quick reply:`;
                    }
                } else {
                    // Normal response
                    prompt = `You're scrolling Pokemon Twitter and see this:

@${username}: "${tweetContent}"
${hasImages ? 'They posted a pic of cards' : ''}

You're a knowledgeable Pokemon card collector. Choose ONE approach:
1. Ask a specific question about their post
2. Give helpful advice or information  
3. Make an observation about what they're showing
4. Share relevant market/pricing info
5. Appreciate what they're sharing

Focus on being helpful and specific to their post.
${hasImages ? 
'Comment on the specific cards/condition visible.' : 
'Respond directly to what they wrote.'}
Be concise. No hashtags or emojis.

Your response:`;
                }

                const result = await model.generateContent(prompt);
                let response = result.response.text().trim()
                    .replace(/^[\"']|[\"']$/g, '')
                    .replace(/#\w+/g, '')
                    .split('\n')[0]  // Take first line only
                    .trim();
                
                // Use clampTweet for consistent handling
                response = clampTweet(response, 280);
                
                console.log(`   ü§ñ [Gemini] "${response}"`);
                this.geminiFailures = 0;
                return response;
                
            } catch (error) {
                this.geminiFailures++;
                console.log(`   ‚ö†Ô∏è Gemini failed, trying LM Studio...`);
            }
        }
        
        // Try LM Studio
        if (this.lmStudioAI.available) {
            try {
                let messages;
                if (isConversation) {
                    // Conversational for replies
                    if (isPokemonRelated) {
                        messages = [
                            {
                                role: "system",
                                content: "You're a Pokemon card collector. Reply naturally to what they said. Be specific, not generic. be concise."
                            },
                            {
                                role: "user",
                                content: `@${username} replied: "${tweetContent}". ${hasImages ? 'With pic.' : ''} Reply back:`
                            }
                        ];
                    } else {
                        // Non-Pokemon conversation
                        messages = [
                            {
                                role: "system",
                                content: "You collect Pokemon cards. Reply casually to whatever they said. Be chill and use internet speak. be concise."
                            },
                            {
                                role: "user",
                                content: `@${username}: "${tweetContent}". ${hasImages ? 'Pic included.' : ''} Quick reply:`
                            }
                        ];
                    }
                } else {
                    // Normal response
                    messages = [
                        {
                            role: "system",
                            content: hasImages ? 
                                "Pokemon collector. React to their pic. Use slang: fire, banger, chase, W pull, sheesh. Be concise. Sound casual." :
                                "Pokemon collector. React genuinely. Use: ngl, tbh, lowkey, sick pull, that's heat. Ask about cards. Be concise."
                        },
                        {
                            role: "user",
                            content: `@${username}: "${tweetContent}". ${hasImages ? 'Posted cards pic.' : 'No pic.'} Your reaction:`
                        }
                    ];
                }
                
                const response = await this.lmStudioAI.generateDirectResponse(messages);
                if (response) {
                    // Remove any surrounding quotes
                    const cleaned = response.replace(/^["']|["']$/g, '').trim();
                    console.log(`   ü§ñ [LM Studio] "${cleaned}"`);
                    return cleaned;
                }
            } catch (error) {
                console.log(`   ‚ö†Ô∏è LM Studio error: ${error.message}`);
            }
        }
        
        // Fallback: Context-aware templates
        return this.generateFallbackResponse(tweetContent, hasImages);
    }
    
    async generateFallbackResponse(tweetContent, hasImages) {
        const textLower = tweetContent.toLowerCase();
        
        // Extract key information from tweet
        const cards = this.extractCardNames(textLower);
        const prices = this.extractPrices(textLower);
        const isQuestion = tweetContent.includes('?');
        
        // Determine context and respond appropriately
        if (cards.length > 0) {
            const card = cards[0];
            
            // Try to get real price data if available
            if (this.priceEngineReady) {
                const priceData = await priceEngine.getQuickPrice(card);
                if (priceData) {
                    const priceStr = priceEngine.formatPriceResponse(priceData, 'casual');
                    
                    if (textLower.includes('pull') || textLower.includes('pulled')) {
                        return `${card} is straight fire, ${priceStr} raw`;
                    } else if (prices.length > 0) {
                        return `${prices[0]} for ${card}? market's at ${priceStr}`;
                    } else if (textLower.includes('grade') || textLower.includes('psa')) {
                        return `that ${card} def PSA 10 worthy, ${priceStr} raw rn`;
                    } else {
                        return `${card} goes hard, ${priceStr} market`;
                    }
                }
            }
            
            // Fallback without price
            if (textLower.includes('pull') || textLower.includes('pulled')) {
                return `${card} is straight fire ngl`;
            } else if (prices.length > 0) {
                return `${prices[0]} for ${card}? not bad tbh`;
            } else if (textLower.includes('grade') || textLower.includes('psa')) {
                return `that ${card} def PSA 10 worthy if centering's good`;
            } else {
                return `${card} goes hard fr`;
            }
        }
        
        if (textLower.includes('mail day') || textLower.includes('mailday')) {
            return hasImages ? "sheesh mail day W" : "mail day hits different, whatd you get?";
        }
        
        if (textLower.includes('collection') || textLower.includes('binder')) {
            return "collection goes crazy ngl";
        }
        
        if (isQuestion) {
            if (textLower.includes('worth') || textLower.includes('value')) {
                return "check tcgplayer, prices been wild lately";
            } else if (textLower.includes('real') || textLower.includes('fake')) {
                return "texture test never lies, check the holo pattern";
            } else {
                return "good question tbh";
            }
        }
        
        // Generic but still Pokemon-relevant
        return hasImages ? "those are heat fr" : "W post";
    }
    
    extractCardNames(text) {
        const cards = [];
        const cardPatterns = [
            /charizard/gi, /pikachu/gi, /moonbreon/gi, /umbreon/gi,
            /rayquaza/gi, /lugia/gi, /mewtwo/gi, /gengar/gi,
            /blaziken/gi, /gyarados/gi, /dragonite/gi, /garchomp/gi,
            /sylveon/gi, /leafeon/gi, /glaceon/gi, /vaporeon/gi
        ];
        
        for (const pattern of cardPatterns) {
            const matches = text.match(pattern);
            if (matches) {
                cards.push(matches[0]);
            }
        }
        
        return cards;
    }
    
    extractPrices(text) {
        const prices = [];
        const pricePattern = /\$(\d+(?:,\d{3})*(?:\.\d{2})?)/g;
        let match;
        
        while ((match = pricePattern.exec(text)) !== null) {
            prices.push(match[0]);
        }
        
        return prices;
    }

    async sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    async random(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    async checkRateLimit() {
        // Clean up old entries (older than 1 hour)
        const oneHourAgo = Date.now() - (60 * 60 * 1000);
        this.repliesThisHour = this.repliesThisHour.filter(time => time > oneHourAgo);
        
        // Check if we've hit the rate limit (15 replies per hour)
        if (this.repliesThisHour.length >= 15) {
            const oldestReply = Math.min(...this.repliesThisHour);
            const timeSinceOldest = Date.now() - oldestReply;
            const waitTime = (60 * 60 * 1000) - timeSinceOldest;
            
            if (waitTime > 0) {
                console.log(`\n‚ö†Ô∏è RATE LIMIT: ${this.repliesThisHour.length} replies in last hour`);
                console.log(`   ‚è∞ Waiting ${Math.ceil(waitTime / 60000)} minutes...`);
                await this.sleep(waitTime);
                this.repliesThisHour = []; // Reset after waiting
            }
        }
    }

    async checkForBreak() {
        // Take a break every 20 replies
        const repliesSinceBreak = this.replyCount - this.lastBreakReplyCount;
        
        if (repliesSinceBreak >= 20) {
            const breakTime = await this.random(5 * 60 * 1000, 10 * 60 * 1000); // 5-10 minutes
            console.log(`\n‚òï BREAK TIME: Taking ${Math.floor(breakTime / 60000)} minute break after ${repliesSinceBreak} replies`);
            console.log(`   üìä Total replies: ${this.replyCount}`);
            console.log(`   üí§ Resting to avoid detection...\n`);
            
            await this.sleep(breakTime);
            this.lastBreakReplyCount = this.replyCount;
            console.log(`   ‚úÖ Break complete, resuming...\n`);
        }
    }

    async humanType(element, text) {
        await element.click();
        await this.sleep(500);
        
        for (let char of text) {
            await this.page.keyboard.type(char);
            await this.sleep(await this.random(40, 80));
        }
    }

    async checkAndReplyToConversations() {
        try {
            console.log('\nüí¨ Checking for conversation replies...');
            const conversations = await this.conversationChecker.checkForReplies();
            
            if (conversations.length === 0) {
                console.log('   No new conversation replies found');
                return;
            }
            
            let newConversations = 0;
            
            for (const conv of conversations.slice(0, 5)) { // Check up to 5
                const { data } = conv;
                
                // Check if we've already processed this conversation
                if (await this.conversationTracker.hasProcessed(data.tweetId)) {
                    console.log(`   ‚è≠Ô∏è Already replied to @${data.username}'s tweet`);
                    continue;
                }
                
                // Stop after 2 new conversations
                if (newConversations >= 2) break;
                
                console.log(`   üéØ Found NEW reply from @${data.username}: "${data.tweetText.substring(0, 50)}..."`);
                
                // Navigate to the reply (this now includes thread context)
                const tweetElement = await this.conversationChecker.navigateToReply(data);
                if (!tweetElement) continue;
                
                // Generate thread-aware conversational response
                let response;
                if (data.threadContext) {
                    // Use full thread context for better response
                    response = await this.generateThreadAwareResponse(
                        data.username,
                        data.tweetText,
                        data.threadContext
                    );
                } else {
                    // Fallback to regular response
                    response = await this.generateContextualResponse(
                        data.username,
                        data.tweetText,
                        false
                    );
                }
                
                if (!response) continue;
                
                // Reply to continue conversation
                const success = await this.replyToTweet(tweetElement, response);
                if (success) {
                    this.replyCount++;
                    newConversations++;
                    this.repliesThisHour.push(Date.now()); // Track for rate limiting
                    console.log(`   ‚úÖ Continued conversation! [${this.replyCount}/1000]`);
                    
                    // Mark as processed
                    await this.conversationTracker.markAsProcessed(data.tweetId, data.username, data.tweetText);
                    
                    // Update memory
                    await this.memory.rememberUser(data.username, data.tweetText);
                    await this.memory.saveUsers();
                    
                    // Check if we need a break
                    await this.checkForBreak();
                    
                    // Check rate limit
                    await this.checkRateLimit();
                }
                
                await this.sleep(3000);
            }
            
            if (newConversations > 0) {
                console.log(`   üìä Processed ${newConversations} new conversations`);
                await this.conversationTracker.save();
            }
            
            // Navigate back to search
            console.log('   üìç Returning to search...\n');
            
        } catch (error) {
            console.log(`   ‚ùå Conversation check error: ${error.message}\n`);
        }
    }

    async replyToTweet(tweetElement, response) {
        try {
            // Click reply button
            const replyButton = await tweetElement.$('button[data-testid="reply"]');
            if (!replyButton) return false;
            
            await replyButton.click();
            await this.sleep(3000);
            
            const replyBox = await this.page.waitForSelector(
                'div[data-testid="tweetTextarea_0"]',
                { timeout: 10000 }
            ).catch(() => null);
            
            if (!replyBox) {
                await this.page.keyboard.press('Escape');
                return false;
            }
            
            await this.humanType(replyBox, response);
            await this.sleep(2000);
            
            // Send
            const sent = await this.page.evaluate(() => {
                const btn = document.querySelector('button[data-testid="tweetButton"]');
                if (btn && !btn.disabled) {
                    btn.click();
                    return true;
                }
                return false;
            });
            
            if (!sent) {
                await this.page.keyboard.down('Meta');
                await this.page.keyboard.press('Enter');
                await this.page.keyboard.up('Meta');
            }
            
            await this.sleep(3000);
            return true;
            
        } catch (error) {
            console.log(`   ‚ùå Reply error: ${error.message}`);
            return false;
        }
    }

    async init() {
        console.log('üöÄ Pokemon TCG Bot - CONTEXTUAL VERSION');
        console.log('========================================');
        console.log('‚úÖ Context-aware responses');
        console.log('‚úÖ Actually reads tweets');
        console.log('‚úÖ Specific, not generic');
        console.log('‚úÖ Content filtering\n');
        
        await this.memory.initialize();
        await this.conversationTracker.initialize();
        
        // Load previously replied users into our Set
        for (const [username, userData] of this.memory.users.entries()) {
            if (userData.interactionCount > 0) {
                this.repliedUsers.add(username.toLowerCase());
            }
        }
        console.log(`   üìù Loaded ${this.repliedUsers.size} previously replied users`);
        
        try {
            console.log('üîå Connecting to Chrome...');
            this.browser = await puppeteer.connect({
                browserURL: 'http://127.0.0.1:9222',
                defaultViewport: null
            });
            
            const pages = await this.browser.pages();
            for (const page of pages) {
                const url = page.url();
                if (url.includes('x.com') || url.includes('twitter.com')) {
                    this.page = page;
                    console.log(`‚úÖ Connected to X.com\n`);
                    break;
                }
            }
            
            if (!this.page && pages.length > 0) {
                this.page = pages[0];
                await this.page.goto('https://x.com/home', { 
                    waitUntil: 'networkidle2',
                    timeout: 30000 
                });
            }
            
            // Initialize conversation checker now that page is ready
            if (this.page) {
                this.conversationChecker = new ConversationChecker(this.page);
                this.visualAnalyzer = new VisualAnalyzer(this.page);
                console.log('üí¨ Conversation checker initialized');
            }
            
            return !!this.page;
            
        } catch (error) {
            console.log('‚ùå Connection error:', error.message);
            return false;
        }
    }

    async checkPageHealth() {
        try {
            // Check if page is still connected
            const isConnected = this.page && !this.page.isClosed();
            if (!isConnected) {
                console.log('‚ö†Ô∏è Page disconnected, reconnecting...');
                return await this.init();
            }
            
            // Check if we're still on X/Twitter
            const url = this.page.url();
            if (!url.includes('x.com') && !url.includes('twitter.com')) {
                console.log('‚ö†Ô∏è Not on X.com, navigating back...');
                await this.page.goto('https://x.com/home', {
                    waitUntil: 'domcontentloaded',
                    timeout: 20000
                }).catch(() => {});
                await this.sleep(3000);
            }
            
            return true;
        } catch (error) {
            console.log('‚ö†Ô∏è Page health check failed:', error.message);
            return false;
        }
    }

    async processTimeline() {
        console.log('üîç Starting contextual engagement...\n');
        
        let searchCounter = 0;
        let errorCount = 0;
        
        while (this.replyCount < 1000) {
            try {
                // Check page health every 10 searches
                if (searchCounter % 10 === 0) {
                    const healthy = await this.checkPageHealth();
                    if (!healthy) {
                        console.log('‚ö†Ô∏è Page unhealthy, attempting recovery...');
                        await this.sleep(10000);
                        continue;
                    }
                }
                
                // Reset error count on successful iteration
                if (errorCount > 0 && searchCounter % 5 === 0) {
                    errorCount = 0;
                }
                
                // Check for conversation replies every 7 searches
                if (searchCounter > 0 && searchCounter % 7 === 0 && this.conversationChecker) {
                    await this.checkAndReplyToConversations();
                }
                
                const query = this.searchEngine.getTrendingSearch();
                console.log(`üìç Searching: "${query}"`);
                searchCounter++;
                
                // Perform human-like search instead of direct URL navigation
                let navigationSuccess = false;
                for (let navRetry = 0; navRetry < 3; navRetry++) {
                    try {
                        navigationSuccess = await this.humanSearch.performSearch(this.page, query);
                        if (navigationSuccess) break;
                    } catch (searchError) {
                        console.log(`‚ö†Ô∏è Human search attempt ${navRetry + 1} failed: ${searchError.message}`);
                        if (navRetry === 2) {
                            // Final fallback to direct navigation
                            console.log('‚ö†Ô∏è Falling back to direct URL navigation');
                            try {
                                await this.page.goto(`https://x.com/search?q=${encodeURIComponent(query)}&f=live`, {
                                    waitUntil: 'domcontentloaded',
                                    timeout: 20000
                                });
                                navigationSuccess = true;
                            } catch (fallbackError) {
                                console.log('‚ö†Ô∏è Even fallback navigation failed');
                            }
                        }
                        await this.sleep(3000);
                    }
                }
                
                if (!navigationSuccess) {
                    console.log('‚ö†Ô∏è Could not navigate, checking current page...');
                    const currentUrl = this.page.url();
                    if (!currentUrl.includes('x.com')) {
                        // Try to recover by going to home first
                        await this.page.goto('https://x.com/home', {
                            waitUntil: 'domcontentloaded',
                            timeout: 20000
                        }).catch(() => {});
                        await this.sleep(3000);
                    }
                    continue;  // Skip this search iteration
                }
                
                await this.sleep(await this.random(5000, 8000));
                
                // Collect all tweets we can see with scrolling
                const seenTweets = [];
                const processedTweetIds = new Set();
                
                console.log(`üìä Collecting tweets for engagement analysis...`);
                
                for (let scroll = 0; scroll < 5; scroll++) {
                    const tweets = await this.page.$$('article[data-testid="tweet"]');
                    
                    // Add only new tweets
                    for (const tweet of tweets) {
                        const tweetId = await tweet.evaluate(el => {
                            const link = el.querySelector('a[href*="/status/"]');
                            return link?.href || Math.random().toString();
                        });
                        
                        if (!processedTweetIds.has(tweetId)) {
                            processedTweetIds.add(tweetId);
                            seenTweets.push(tweet);
                        }
                    }
                    
                    // Scroll to see more
                    await this.page.evaluate(() => {
                        window.scrollBy({ top: 600, behavior: 'smooth' });
                    });
                    await this.sleep(await this.random(2000, 3000));
                }
                
                console.log(`üìä Collected ${seenTweets.length} unique tweets`);
                
                // If no tweets found, try a simpler fallback search
                if (seenTweets.length === 0) {
                    console.log('‚ö†Ô∏è No tweets found, trying fallback search...');
                    
                    const fallbackQuery = this.searchEngine.getFallbackSearch();
                    const fallbackSuccess = await this.humanSearch.performSearch(this.page, fallbackQuery);
                    
                    if (fallbackSuccess) {
                        await this.sleep(2000);
                        
                        // Try collecting tweets again with fallback
                        for (let scroll = 0; scroll < 3; scroll++) {
                            const tweets = await this.page.$$('article[data-testid="tweet"]');
                            
                            for (const tweet of tweets) {
                                const tweetId = await tweet.evaluate(el => {
                                    const link = el.querySelector('a[href*="/status/"]');
                                    return link?.href || Math.random().toString();
                                });
                                
                                if (!processedTweetIds.has(tweetId)) {
                                    processedTweetIds.add(tweetId);
                                    seenTweets.push(tweet);
                                }
                            }
                            
                            await this.page.evaluate(() => {
                                window.scrollBy({ top: 400, behavior: 'smooth' });
                            });
                            await this.sleep(2000);
                        }
                        
                        console.log(`üìä Fallback collected ${seenTweets.length} tweets`);
                    }
                }
                
                // Calculate target engagements (15% of what we saw)
                const targetEngagements = Math.ceil(seenTweets.length * 0.15);
                const maxPerSearch = 3; // Safety limit per search
                const actualTarget = Math.min(targetEngagements, maxPerSearch);
                
                console.log(`üéØ Target: ${actualTarget} engagements (15% of ${seenTweets.length})`);
                
                let engagementsThisRound = 0;
                const engagedTweets = [];
                
                // Try to engage with our target number of tweets
                for (const tweet of seenTweets) {
                    if (engagementsThisRound >= actualTarget) break;
                    
                    // Check hourly rate limit
                    const recentReplies = this.repliesThisHour.filter(
                        time => Date.now() - time < 3600000
                    );
                    if (recentReplies.length >= 15) {
                        console.log(`‚ö†Ô∏è Hourly limit reached (${recentReplies.length}/15), will resume later`);
                        break;
                    }
                    
                    const decision = await this.analyzeTweet(tweet);
                    
                    if (decision && decision.engage) {
                        const success = await this.engageWithTweet(tweet, decision.action);
                        if (success) {
                            engagementsThisRound++;
                            engagedTweets.push(tweet);
                            this.stats.successfulEngagements++;
                            
                            // Track for rate limiting
                            this.repliesThisHour.push(Date.now());
                            
                            // Update engagement selector AFTER successful reply
                            const tweetData = await tweet.evaluate(el => {
                                const username = el.querySelector('a[href^="/"]')?.getAttribute('href')?.substring(1) || 'unknown';
                                return username;
                            });
                            this.engagementSelector.updateAfterReply(tweetData);
                            
                            // Wait between engagements (longer if multiple)
                            if (engagementsThisRound < actualTarget) {
                                const waitTime = await this.random(30000, 60000);
                                console.log(`‚è∞ Engagement ${engagementsThisRound}/${actualTarget} complete. Waiting ${Math.floor(waitTime/1000)}s...\n`);
                                await this.sleep(waitTime);
                            }
                        }
                    }
                }
                
                console.log(`‚úÖ Completed ${engagementsThisRound}/${actualTarget} engagements this round\n`);
                
                // Show stats periodically
                if (this.replyCount % 10 === 0) {
                    this.showStats();
                }
                
            } catch (error) {
                errorCount++;
                console.log(`‚ö†Ô∏è Error: ${error.message}\n`);
                
                // If too many errors, take a longer break
                if (errorCount > 5) {
                    console.log('‚ö†Ô∏è Too many errors, taking extended break...');
                    await this.sleep(60000);  // 1 minute break
                    errorCount = 0;
                    
                    // Try to reset by going back to home
                    try {
                        await this.page.goto('https://x.com/home', {
                            waitUntil: 'domcontentloaded',
                            timeout: 20000
                        });
                    } catch (resetError) {
                        console.log('‚ö†Ô∏è Reset failed, will retry...');
                    }
                } else {
                    await this.sleep(10000);
                }
            }
        }
    }

    async analyzeTweet(tweet) {
        try {
            const data = await tweet.evaluate(el => {
                const username = el.querySelector('a[href^="/"]')?.getAttribute('href')?.substring(1);
                const text = el.querySelector('[data-testid="tweetText"]')?.innerText || '';
                const hasImages = !!el.querySelector('img[alt*="Image"]');
                const hasVideos = !!el.querySelector('video, [data-testid="videoPlayer"]');
                return { username, text, hasImages, hasVideos };
            });
            
            if (!data.username || !data.text || data.text.length < 20) {
                return false;
            }
            
            // FIRST: Check if post is recent enough to avoid bot detection
            const postTimestamp = await this.timestampFilter.extractTimestamp(tweet);
            const timestampDecision = this.timestampFilter.shouldEngageByAge(postTimestamp);
            
            if (!timestampDecision.engage) {
                console.log(`   üïê Skipping old post: ${timestampDecision.details}`);
                return false;
            }
            
            // Log post age for monitoring
            const ageDescription = this.timestampFilter.getAgeDescription(postTimestamp);
            console.log(`   üïê Post age: ${ageDescription} (${timestampDecision.reason})`);
        
            
            // Use engagement selector to decide if we should engage
            const engagementDecision = await this.engagementSelector.shouldEngageWithPost(tweet, data);
            if (engagementDecision.action === 'skip') {
                console.log(`   ‚è≠Ô∏è [Selector] Skipping: ${engagementDecision.reason}`);
                return false;
            }
            
            // Store engagement type for later use
            data.engagementType = engagementDecision.action; // 'like' or 'reply'
            
            // Skip our own bot
            if (data.username.toLowerCase() === 'glitchygradeai') {
                return false;
            }
            
            // Check if this is a reply to our bot (allow conversations)
            const isReplyToUs = data.text.toLowerCase().includes('@glitchygradeai');
            
            if (isReplyToUs) {
                // This is a conversation - check with lenient filter
                const filterResult = this.contentFilter.shouldEngageWithPost(data.text, data.username, true);
                
                if (!filterResult.engage) {
                    console.log(`   üö´ Conversation filtered: ${filterResult.reason}`);
                    return false;
                }
                
                console.log(`   üí¨ Continuing conversation with @${data.username}`);
                return true; // Respond to conversation
            }
            
            // For non-replies, check if we've already interacted
            const usernameLower = data.username.toLowerCase();
            
            // Check if we've already replied to this user's original posts this session
            if (this.repliedUsers.has(usernameLower)) {
                return false;
            }
            
            // Check if we've interacted before (but allow if significant time has passed)
            const existingUser = this.memory.users.get(data.username);
            if (existingUser && existingUser.interactionCount > 0) {
                // Allow re-interaction after 6 hours (reduced from 24)
                const lastSeen = new Date(existingUser.lastSeen);
                const hoursSinceLastInteraction = (Date.now() - lastSeen.getTime()) / (1000 * 60 * 60);
                
                if (hoursSinceLastInteraction < 6) {
                    console.log(`   ‚è≠Ô∏è Already interacted with @${data.username} recently`);
                    this.repliedUsers.add(usernameLower); // Add to Set for this session
                    return false;
                } else {
                    console.log(`   üîÑ Re-engaging with @${data.username} after ${Math.floor(hoursSinceLastInteraction)} hours`);
                }
            }
            
            const filterResult = this.contentFilter.shouldEngageWithPost(data.text, data.username, false);
            
            if (!filterResult.engage) {
                console.log(`   üö´ Filtered: ${filterResult.reason}`);
                this.stats.postsFiltered++;
                return false;
            }
            
            // ADDITIONAL CHECK: Ensure the tweet is ACTUALLY about Pokemon TCG
            // Not just matching our search terms coincidentally
            const textLower = data.text.toLowerCase();
            const definitelyPokemon = 
                textLower.includes('pokemon') || textLower.includes('pok√©mon') ||
                textLower.includes('tcg') || textLower.includes('psa') ||
                textLower.includes('charizard') || textLower.includes('pikachu') ||
                textLower.includes('card') && (textLower.includes('pull') || textLower.includes('collection')) ||
                textLower.includes('booster') || textLower.includes('etb') ||
                data.hasImages && (textLower.includes('mail') || textLower.includes('got'));
            
            if (!definitelyPokemon) {
                // If no clear Pokemon indicators, skip unless it has images
                if (!data.hasImages) {
                    console.log(`   ‚è≠Ô∏è Not clearly Pokemon TCG related`);
                    return false;
                }
            }
            
            this.stats.postsAnalyzed++;
            
            // Build quick features for ValueScore
            const isPriceQ = /\b(worth|price|value|how much|going for|\$)\b/i.test(data.text);
            const cards = this.extractCardNames(data.text.toLowerCase());
            const threadLen = 0; // default; if you add thread scraping, fill this in
            
            // ValueScore: data-first > context > vibes
            function computeValueScore() {
                let s = 0;
                if (isPriceQ && cards.length) s += 3;
                if (timestampDecision.reason === 'recent_post') s += 2;            // fresh
                if (data.hasImages) s += 1;                                        // we can comment condition
                if (filterResult.quality >= 2) s += 1;                             // your own quality gate
                return s;
            }
            const score = computeValueScore();
            
            // Decide engagement deterministically
            if (score < 3) return false; // skip
            
            // Respect engagementSelector's action (like vs reply)
            return { 
                engage: true, 
                action: data.engagementType || 'reply', 
                username: data.username, 
                text: data.text, 
                hasImages: data.hasImages,
                score: score
            };
            
        } catch (error) {
            return false;
        }
    }

    // Helper to get thread context from status page
    async getThreadContextFromStatusPage(page) {
        // assumes you're on the status page
        const nodes = await page.$$('[data-testid="cellInnerDiv"] article[data-testid="tweet"]');
        const msgs = [];
        for (const n of nodes.slice(-6)) {
            const m = await n.evaluate(el => {
                const u = el.querySelector('a[href^="/"]')?.getAttribute('href')?.split('/')[1] || 'user';
                const t = el.querySelector('[data-testid="tweetText"]')?.innerText || '';
                return { username: u, text: t };
            });
            if (m.text) msgs.push(m);
        }
        const topic = /(charizard|umbreon|pikachu|tcg|grade|psa|binder|pull|evolving skies|lost origin)/i
                        .exec(msgs.map(x=>x.text).join(' '))?.[0] || 'Pokemon TCG';
        return { threadLength: msgs.length, mainTopic: topic, fullConversation: msgs };
    }
    
    async engageWithTweet(tweet, action = 'reply') {
        try {
            const data = await tweet.evaluate(el => {
                const username = el.querySelector('a[href^="/"]')?.getAttribute('href')?.substring(1);
                const text = el.querySelector('[data-testid="tweetText"]')?.innerText || '';
                const hasImages = !!el.querySelector('img[alt*="Image"]');
                const hasVideos = !!el.querySelector('video, [data-testid="videoPlayer"]');
                return { username, text, hasImages, hasVideos };
            });
            
            console.log(`\nüí¨ @${data.username}: "${data.text.substring(0, 80)}..."`);
            
            // Learn from post
            const user = await this.memory.rememberUser(data.username, data.text);
            await this.memory.learnFromPost(data.text, { username: data.username });
            
            // Save memory after each interaction
            await this.memory.saveUsers();
            await this.memory.saveKnowledge();
            console.log(`   üíæ Memory saved (${this.memory.users.size} users, ${this.memory.knowledge.prices.size} prices)`);
            
            // Try to like the tweet first
            await this.tryLikeTweet(tweet);
            
            // If action is like-only, we're done
            if (action === 'like') {
                console.log('   üëç Like-only per selector. Skipping reply.');
                return true;
            }
            
            // BEFORE opening the reply modal, open the status in a new tab to harvest context
            const url = await tweet.evaluate(el => el.querySelector('a[href*="/status/"]')?.href);
            let threadContext = null;
            if (url) {
                const ctxPage = await this.browser.newPage();
                try {
                    await ctxPage.goto(url, { waitUntil: 'domcontentloaded', timeout: 20000 });
                    await this.sleep(2000);
                    threadContext = await this.getThreadContextFromStatusPage(ctxPage);
                } catch (e) { 
                    console.log(`   ‚ö†Ô∏è Could not get thread context: ${e.message}`);
                }
                await ctxPage.close();
            }
            
            // Analyze visual content if present
            let visualData = null;
            if (data.hasImages || data.hasVideos) {
                if (this.visualAnalyzer) {
                    visualData = await this.visualAnalyzer.analyzeVisualContent(tweet);
                    if (visualData && visualData.analysis) {
                        console.log(`   üñºÔ∏è Visual: ${visualData.analysis.contentType} - ${visualData.analysis.focusArea}`);
                    }
                }
            }
            
            // Generate contextual response with thread context if available
            const response = threadContext
                ? await this.generateThreadAwareResponse(data.username, data.text, threadContext)
                : await this.generateContextualResponse(
                    data.username, 
                    data.text, 
                    data.hasImages,
                    visualData
                );
            
            // Scroll to tweet
            await tweet.evaluate(el => el.scrollIntoView({ behavior: 'smooth', block: 'center' }));
            await this.sleep(2000);
            
            // Reply
            const replyButton = await tweet.$('button[data-testid="reply"]');
            if (!replyButton) return false;
            
            await replyButton.click();
            console.log(`   üí≠ Replying...`);
            await this.sleep(3000);
            
            const replyBox = await this.page.waitForSelector(
                'div[data-testid="tweetTextarea_0"]',
                { timeout: 10000 }
            ).catch(() => null);
            
            if (!replyBox) {
                await this.page.keyboard.press('Escape');
                return false;
            }
            
            await this.humanType(replyBox, response);
            await this.sleep(2000);
            
            // Send
            const sent = await this.page.evaluate(() => {
                const btn = document.querySelector('button[data-testid="tweetButton"]');
                if (btn && !btn.disabled) {
                    btn.click();
                    return true;
                }
                return false;
            });
            
            if (!sent) {
                await this.page.keyboard.down('Meta');
                await this.page.keyboard.press('Enter');
                await this.page.keyboard.up('Meta');
            }
            
            await this.sleep(3000);
            
            const success = await this.page.$('div[data-testid="tweetTextarea_0"]')
                .then(el => el === null);
            
            if (success) {
                this.replyCount++;
                this.repliedUsers.add(data.username.toLowerCase());
                this.repliesThisHour.push(Date.now()); // Track for rate limiting
                console.log(`   ‚úÖ Sent! [${this.replyCount}/1000]`);
                
                // Update engagement selector AFTER successful reply
                this.engagementSelector.updateAfterReply(data.username);
                
                // Check if we need a break
                await this.checkForBreak();
                
                // Check rate limit
                await this.checkRateLimit();
                
                return true;
            }
            
            await this.page.keyboard.press('Escape');
            return false;
            
        } catch (error) {
            console.log(`   ‚ùå Error: ${error.message}`);
            return false;
        }
    }

    async tryLikeTweet(tweet) {
        // Like with multiple attempts
        let liked = false;
        const likeSelectors = [
            'button[data-testid="like"]',
            'button[aria-label*="Like"]',
            'div[role="button"][aria-label*="Like"]'
        ];
        
        for (const selector of likeSelectors) {
            if (liked) break;
            const likeButton = await tweet.$(selector);
            if (likeButton) {
                try {
                    await likeButton.click();
                    console.log(`   ‚ù§Ô∏è Liked`);
                    liked = true;
                    await this.sleep(1500);
                } catch (e) {
                    // Try next selector
                }
            }
        }
        return liked;
    }
    
    showStats() {
        const runtime = Math.floor((Date.now() - this.startTime) / 60000);
        
        console.log('\nüìä === BOT STATISTICS ===');
        console.log(`   Replies: ${this.replyCount}`);
        console.log(`   Runtime: ${runtime} min`);
        console.log(`   Rate: ${(this.replyCount / Math.max(runtime, 1)).toFixed(1)}/min`);
        console.log(`   Analyzed: ${this.stats.postsAnalyzed}`);
        console.log(`   Filtered: ${this.stats.postsFiltered}`);
        console.log(`   Success rate: ${((this.stats.successfulEngagements / Math.max(this.stats.postsAnalyzed, 1)) * 100).toFixed(1)}%`);
        
        const memStats = this.memory.getMemoryStats();
        console.log(`   Users: ${memStats.totalUsers}`);
        console.log(`   Prices learned: ${memStats.totalKnowledge.prices}`);
        console.log('========================\n');
    }

    async generatePriceAwareResponse(tweetContent, username, hasImages) {
        try {
            const textLower = tweetContent.toLowerCase();
            const ents = this.extractCardEntities ? this.extractCardEntities(tweetContent) : null;
            const cards = ents?.length ? [ents[0].name] : this.extractCardNames(textLower);
            
            if (cards.length > 0) {
                const primary = ents?.[0] || { name: cards[0], set: this.extractSetName(textLower) || null };
                let stats = null;
                
                // Try to get stats from price engine
                if (this.priceEngineReady && priceEngine.getStatsFor) {
                    try {
                        stats = await priceEngine.getStatsFor(primary.name, primary.set, primary.number);
                    } catch (e) {
                        console.log('   ‚ö†Ô∏è Could not get stats:', e.message);
                    }
                }
                
                // If we have stats, use authority response with numbers
                if (stats && Object.keys(stats).length > 0) {
                    const line = this.authorityResponses.generateAuthorityWithStats({
                        setName: primary.set,
                        cardDisplay: `${primary.name}${primary.number ? ' ' + primary.number : ''}${primary.set ? ' (' + primary.set + ')' : ''}`,
                        stats
                    });
                    return clampTweet(line, 280);
                }
                
                // Fallback to regular price response
                const response = await this.priceResponses.generatePriceResponse(primary.name, primary.set, 'casual');
                if (response) {
                    return clampTweet(response, 280);
                }
            }
            
            return null;
        } catch (error) {
            console.log('   ‚ö†Ô∏è Price response error:', error.message);
            return null;
        }
    }
    
    shouldIncludePrice(text) {
        const priceTriggers = [
            'worth', 'price', 'value', 'cost', 'how much',
            'what\'s it', 'going for', 'market', 'tcgplayer',
            'sell', 'buy', 'trade', '$'
        ];
        
        const lowerText = text.toLowerCase();
        return priceTriggers.some(trigger => lowerText.includes(trigger));
    }
    
    // Card nickname resolution for better price matching
    CARD_NICKNAMES = {
        moonbreon: { name: 'Umbreon VMAX', set: 'Evolving Skies', number: '215/203' },
        zard: { name: 'Charizard' },
        tina: { name: 'Giratina' },
        rayray: { name: 'Rayquaza VMAX' },
        pika: { name: 'Pikachu' },
        eevee: { name: 'Eevee' },
        mew2: { name: 'Mewtwo' },
        gary: { name: 'Gyarados' },
        blast: { name: 'Blastoise' },
        venu: { name: 'Venusaur' }
    };
    
    // Set abbreviations for better entity resolution
    SET_ABBREVIATIONS = {
        'evs': 'Evolving Skies',
        'es': 'Evolving Skies',
        'lor': 'Lost Origin',
        'lo': 'Lost Origin',
        'sit': 'Silver Tempest',
        'st': 'Silver Tempest',
        'brs': 'Brilliant Stars',
        'bs': 'Brilliant Stars',
        'cz': 'Crown Zenith',
        'sv': 'Scarlet & Violet',
        'pgo': 'Pokemon GO',
        'prf': 'Paradox Rift',
        'pr': 'Paradox Rift',
        'obf': 'Obsidian Flames',
        'of': 'Obsidian Flames',
        'pal': 'Paldea Evolved',
        'pe': 'Paldea Evolved',
        'tmp': 'Temporal Forces',
        'tf': 'Temporal Forces',
        'shf': 'Shining Fates',
        'hf': 'Hidden Fates',
        'vv': 'Vivid Voltage',
        'cr': 'Chilling Reign',
        'fs': 'Fusion Strike',
        'cel': 'Celebrations',
        'upc': 'Ultimate Premium Collection'
    };
    
    extractCardEntities(text) {
        const t = text.toLowerCase();
        const ents = [];
        
        // Check for nicknames
        for (const k in this.CARD_NICKNAMES) {
            if (t.includes(k)) ents.push({...this.CARD_NICKNAMES[k]});
        }
        
        // Extract regular card names
        const base = this.extractCardNames(t).map(n => ({ name: n }));
        
        // Check for set abbreviations
        let expandedSet = this.extractSetName(text);
        for (const [abbrev, fullName] of Object.entries(this.SET_ABBREVIATIONS)) {
            const pattern = new RegExp(`\\b${abbrev}\\b`, 'i');
            if (pattern.test(t)) {
                expandedSet = fullName;
                break;
            }
        }
        
        const num = (t.match(/\b(\d{1,3}\/\d{1,3}[a-z]?)\b/i) || [])[1];
        
        // Language detection
        const isJapanese = /\bjp\b|\bjpn\b|japanese|japan/.test(t);
        const isEnglish = /\ben\b|\beng\b|english/.test(t) || (!isJapanese && t.includes('english'));
        
        // Rarity detection
        const rarityPattern = /\b(alt art|alt|sar|fa|full art|hr|hyper rare|gold star|crystal|shiny|rainbow|secret|promo)\b/i;
        const rarityMatch = t.match(rarityPattern);
        
        return [...ents, ...base].map(e => ({ 
            ...e, 
            set: e.set || expandedSet || undefined, 
            number: e.number || num || undefined,
            language: isJapanese ? 'Japanese' : (isEnglish ? 'English' : undefined),
            rarity: rarityMatch ? rarityMatch[1] : undefined
        })).slice(0, 3);
    }
    
    extractCardNames(text) {
        const cards = [];
        const cardPatterns = [
            /charizard/i, /pikachu/i, /umbreon/i, /rayquaza/i,
            /lugia/i, /mewtwo/i, /gengar/i, /eevee/i,
            /dragonite/i, /gyarados/i, /blastoise/i, /venusaur/i,
            /giratina/i, /garchomp/i, /lucario/i, /zoroark/i,
            /sylveon/i, /glaceon/i, /leafeon/i, /espeon/i,
            /flareon/i, /jolteon/i, /vaporeon/i
        ];
        
        for (const pattern of cardPatterns) {
            const match = text.match(pattern);
            if (match) cards.push(match[0]);
        }
        
        return cards;
    }
    
    extractPrices(text) {
        const prices = [];
        const pricePattern = /\$\d+(\.\d{2})?/g;
        const matches = text.match(pricePattern);
        if (matches) prices.push(...matches);
        return prices;
    }
    
    extractSetName(text) {
        const sets = [
            { pattern: /base set/i, name: 'Base Set' },
            { pattern: /evolving skies/i, name: 'Evolving Skies' },
            { pattern: /lost origin/i, name: 'Lost Origin' },
            { pattern: /silver tempest/i, name: 'Silver Tempest' },
            { pattern: /crown zenith/i, name: 'Crown Zenith' },
            { pattern: /paldea evolved/i, name: 'Paldea Evolved' },
            { pattern: /obsidian flames/i, name: 'Obsidian Flames' },
            { pattern: /paradox rift/i, name: 'Paradox Rift' },
            { pattern: /surging sparks/i, name: 'Surging Sparks' }
        ];
        
        for (const {pattern, name} of sets) {
            if (pattern.test(text)) {
                return name;
            }
        }
        
        return null;
    }
    
    async run() {
        try {
            if (await this.init()) {
                await this.processTimeline();
            }
        } catch (error) {
            console.error('‚ùå Fatal:', error);
        } finally {
            this.showStats();
            console.log('‚úÖ Session complete');
        }
    }
}

// Add helper method to LMStudioAI
LMStudioAI.prototype.generateDirectResponse = async function(messages) {
    if (!this.available) return null;
    
    try {
        const axios = require('axios');
        const response = await axios.post(`${this.baseURL}/chat/completions`, {
            model: this.modelName,
            messages: messages,
            temperature: 0.7,
            max_tokens: 50,  // Reduced to prevent long messages
            stream: false
        }, {
            timeout: 10000,
            headers: { 'Content-Type': 'application/json' }
        });
        
        if (response.data?.choices?.[0]?.message?.content) {
            let aiResponse = response.data.choices[0].message.content.trim()
                .replace(/^["']|["']$/g, '') // Remove surrounding quotes
                .replace(/^[""]|[""]$/g, '') // Remove smart quotes
                .replace(/#\w+/g, '')
                .split('\n')[0]
                .trim();
            
            // Use clampTweet for consistent handling
            aiResponse = clampTweet(aiResponse, 280);
            
            return aiResponse;
        }
        
        return null;
    } catch (error) {
        return null;
    }
};

// Export for testing or run as main script
if (require.main === module) {
    const bot = new ContextualPokemonBot();
    bot.run().catch(console.error);
} else {
    module.exports = ContextualPokemonBot;
}